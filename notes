DSA Challenge Application - Project Documentation
1. Project Overview
Name: ATC DSA Event Challenge App Purpose: A desktop-based coding challenge platform for students to solve Data Structures and Algorithms (DSA) problems. Key Constraints: Designed for "Zero-Cost" deployment to handle 200+ concurrent users without crashing free-tier servers. Deployment Strategy:

Backend: Hosted on Render (Free Tier).
Database: PostgreSQL on Neon.tech (Free Tier).
Client: Distributed as a standalone Windows .exe file using PyInstaller.
2. Architecture & Technology Stack
2.1. Backend (Server)
Framework: Python Flask
ORM: SQLAlchemy
Database:
Production: PostgreSQL (via DATABASE_URL env var)
Local/Dev: SQLite (data/contest_v2.db)
Concurrency: Custom In-Memory JobQueue to serialize code execution and prevent server overload.
Hosting: Render.com
2.2. Frontend (UI)
Core: HTML5, CSS3, Vanilla JavaScript (ES6+)
Templating: Jinja2 (server-side rendering)
Styling: Custom CSS (Dark/Light mode, clean interface)
Editor: Textarea with basic tab-indentation support (Monaco/Ace not explicitly seen, custom implementation).
2.3. Desktop Client (Launcher)
Language: Python
GUI Library: pywebview (wraps the web interface in a native window)
Packaging: PyInstaller (creates the .exe)
Key Features:
Forces Fullscreen mode.
Disables Developer Tools (F12) to prevent cheating.
Acts as a secure browser window pointing to the Render backend.
3. Key Features & Implementation Details
3.1. Code Execution & Judging
Language Support: Python, Java
Execution Flow:
Frontend: Sends code to /api/run or /api/submit.
Queue: Request is added to JobQueue (max 2 concurrent workers). This prevents the server from freezing under load.
Polling: Frontend continuously calls /api/queue/status/<task_id> to check if the job is done.
Executor: backend.executor.py runs the code in a subprocess.
Judge: backend.judge.py compares the user's output with expected output using strict or flexible comparison logic.
3.2. Anti-Cheating System
A multi-layered approach to prevent academic dishonesty:

Strict Fullscreen: The client enforces fullscreen. Escaping it is difficult without closing the app.
Event Listeners (
static/js/contest.js
):
blur: Detects if the user clicks outside the window.
visibilitychange: Detects if the user switches tabs (if running in browser).
fullscreenchange: Detects if the user exits fullscreen.
Violation Tracking:
Every violation sends a request to /api/contest/violation.
Limit: 3 Violations allowed.
Consequence: Automatic disqualification after the 3rd violation.
3.3. Problem Management
Storage: Problems are stored as JSON files in data/problems/.
Structure:
problem_id: Integer ID.
title, description, difficulty.
starter_code: Default code template.
test_cases: Input/Output pairs for judging.
updates: Updating a problem only requires editing the JSON file and deploying the backend.
3.4. Scoring & Leaderboard
Scoring: 10 marks per problem.
Ranking: Based on total score + execution efficiency.
Performance Tiers (Percentile-based):
Gold: Top 30%
Silver: Next 40%
Bronze: Bottom 30%
4. API Documentation
All endpoints are relative to the backend URL.

Authentication & Contest Control
POST /api/register: Register a new participant.
GET /api/contest/status: Get current timer, active status, violation count.
POST /api/contest/end: Voluntarily end the contest.
POST /api/contest/violation: Record a cheating attempt.
Problems & Execution
GET /api/problems: List all available problems.
GET /api/problem/<id>: Get details for a specific problem.
POST /api/run: Queue code for a "Sample Run" (tests against public test case).
POST /api/submit: Queue code for "Final Submission" (tests against all hidden test cases).
GET /api/queue/status/<task_id>: Check the status of a queued job.
Data & Results
GET /api/results: Get current score and solved count.
GET /api/organizer/data: Get full leaderboard data (protected route for organizers).
5. Directory Structure
dsa-challenge-app/
├── app.py                 # Main Flask Application
├── client_launcher.py     # Desktop App Entry Point
├── config.py              # Configuration (DB, Tiers, Paths)
├── backend/               # Core Logic
│   ├── executor.py        # Code Runner (Subprocess)
│   ├── judge.py           # Output Comparator
│   ├── models.py          # Database Schemas (SQLAlchemy)
│   ├── queue_manager.py   # Async Job Queue
│   └── service.py         # Business Logic Layer
├── data/
│   └── problems/          # JSON Problem Files
├── static/                # Frontend Assets
│   ├── css/               # Stylesheets
│   └── js/                # Logic (Interactivity, Polling, Anti-Cheat)
└── templates/             # HTML Templates (Jinja2)
6. Deployment Workflow
Update Problems: Edit 
.json
 files in data/problems.
Push to GitHub: Render auto-deploys the new code.
Build Client: Run pyinstaller "DSA Challenge Client.spec".
Distribute: Send the dist/DSA Challenge Client.exe to students.